# Overview
タイミングの同期やデータ更新など複数のプロセス間で協調的に行うような処理のことを同期処理と呼ぶ。

・なぜ同期処理が必要なのか、つまりレースコンディションについて
・ミューテックス、セマフォ、条件変数、バリア同期、Readers-Writerロック、PThread
-

# レースコンディション

レースコンディション; 複数のプロセスが並行して共有リソースにアクセスした結果引き起こされる、予期しない異常な状態のことを指す。

レースコンディションを引き起こすプログラムコード部分のことをクリティカルセクションと呼ぶ

# アトミック処理

定義
ある処理がアトミックである => その処理の途中状態はシステム的に観測することができず、かつ、もしその処理が失敗した場合は完全に処理前の状態に復元される。

# Compare and Swap(CAS)
    
lock cmpxchgq は アトミックな処理
指定された目入れ中のメモリアクセスは排他的に行われることが保証される

xchgb命令はlockプレフィックスがなくても、lockが付いているものとして扱われる


# Load-Link/Store-Conditional(LL/SC)
x86-64 系では、lock命令プレフィックスを使うことで、メモリへの読み書きを排他的に行うよう指定した。
一方 ARM, RISC-V, POWER, MIPS などのCPUではLoad-Link/Store-Conditional(LL/SC)命令がアトミック処理に用いられる。

LL(LoadLink) -> 排他的に読み込む
SC(StoreConditional) -> LLで指定したメモリへの書き込みが他のCPUによって行われていない場合にのみ書き込みが成功する。

失敗したらリトライすることで見かけ上はアトミックにインクリメントすることができる。

ldxrb, ldxarb
load-acquireにつづく命令は、必ずこの命令が終了した後に実行されることを保証し
store-release命令より以前の命令は、必ずこの命令が終了する前に実行されることを保証する

逆にacquireつきじゃないやつはいつつかうの?

# Mutex
Mutual Exclusion。相互排他。
クリティカルセクションを実行可能なプロセスを高々1つに制限するような同期処理。

共有変数となるフラグを用意しておき、そのフラグがtrueならクリティカルセクションを実行し、そうでなければ実行しないというような処理

lock変数自体がクリティカルセクションになってしまうので、lock変数を TAS関数で更新する => 悲観ロック
・じゃあCASは何に使うの?
・TASってほんとに信頼していいの? 信頼するけど。 

# スピンロック
Mutexの例では、ロックが獲得できるまでループを繰り返した。
このようにリソースの空きをポーリングして確認するような獲得方法をスピンロックと呼ぶ。

アトミック命令は実行速度上のペナルティが大きいため、TASを呼び出すまえ検査してからTASを呼び出すことで改良可能。
(Test and Test and Set = TTAS と呼ぶ)

ただし
・ロックを獲得できるまで何度も共有変数を確認するため、CPUリソースを無駄に消費してしまう
｀・ロックを獲得できなかった場合はコンテキストスイッチで他のプロセスにCPUリソースを明け渡し、計算資源の利用を効率化する場合がある
・またクリティカルセクション実行中に、OSのスケジューラによってOSプロセスが割り込みによって待機状態になってしまった場合には特にペナルティが大きくなる


ユーザランドのアプリケーションではOSによる割り込みを制御することが難しいため、スピンロック単体での利用は推奨さあれず、
PThreadsや言語ライブラリが提供するMutexを利用するか、スピンロックとこれらのライブラリを組み合わせるべきである。


# セマフォ
ロックを獲得できるプロセスを、最大Nプロセスまでに制限することができる。

物理的な計算リソースの制限を設けたい場合などに利用できる。
レースコンディションは防げないことがほとんどのため注意。


# 条件変数
ある条件が満たされない間はプロセスを待機し、条件が満たされたときにプロセスを再開するような同期処理。
