# 食事する哲学者問題
デッドロック問題。
ステートマシンの遷移として考えられる


哲学者が2人の場合の状態遷移図

| 状態名  | P1-L | P1-R | P2-L | P2-R | Next State |
| -------:|-----:|-----:|-----:|-----:|-----------:|
| S0      | F    | F    | F    | F    | S1, S2, S3 |
| S1      | T    | F    | F    | F    | S3, S4     |
| S2      | F    | F    | T    | F    | S3, S5     |
| S3      | T    | F    | T    | F    |            |
| S4      | T    | T    | F    | F    | S0         |
| S5      | F    | F    | T    | T    | S0         |

TODO: 状態遷移図を書く


定義: デッドロックとなる状態機械
状態機械がデッドロックする可能性がある <=> 初期状態から到達可能かつ次の遷移先がないような状態を持つ


参照はずしすると

let val = Arc::new(RwLock::new(true));

let t= thread::spawn(move || {
    let flag = *val.read().unwrap(); // 参照はずしするとロック解放されるの?
    // => 値のcopyを撮ってきているっぽい
})

Rustですらもテクニカルなコード書かなきゃいけないときあるんだな

定義: ライブロックとなる状態機械
状態機械がライブロックする可能性がある <=> 常にいずれかのリソース獲得状態へ到達可能だが、それら状態へは決して到達しないような無限の遷移列が存在する

定義: 飢餓を引き起こす状態機械
状態機械が飢餓を引き起こす可能性がある <=> あるプロセスが存在して、常にそのプロセスのリソース獲得状態へ到達可能だが、その状態へは決して到達しないような無限の遷移列が存在するか、デッドロックとなる状態機械である。

ライブロックと飢餓は似ており、ライブロックはシステム全体に関する問題だが、飢餓は一部のノードに関する問題である。

# 銀行家のアルゴリズム

銀行家のアルゴリズムみたいなrace conditionが発生しそうなアルゴリズムを自分で組んだとき、
テストする・テストを書く・アルゴリズムの正しさを証明するのが難しそう。
アルゴ強者に聞きたい。
デッドロックを検知する手法として、リソース確保に関するグラフを生成し、循環的なリソース確保をしていないかを検査する手法がある。

実際どういう処理に使われているんだろう。リソース確保系に使われるんだろうが。


# 再帰ロック
ロックを獲得中のプロセスがそのロックを解放前に再度そのロックを獲得しようとすること

# 再入可能ロック
再帰ロックを行ってもデッドロック状態に陥らず、処理を続行可能なロック機構のこと


# 擬似覚醒
ある条件が満たされるまで待機中のプロセスが、条件が満たされていないにかかわらず実行状態へ移行すること

