

非同期プログラミングとは、独立して発生するイベントに対する処理を記述するための並行プログラミングの総称である。

非同期プログラミングを実現する方法
- コールバック関数
- シグナル(割り込み)を用いる方法
- OSによるIO多重化
- Future
- async/await


# 5.1 並行サーバー
反復サーバー => クライアントからのリクエストを受け付けた順に処理するサーバー
並行サーバー => リクエストを並行に処理するサーバー


並行サーバーの実装方法
- クライアントからのコネクション要求、データ到着 などの処理をイベントという単位で細かく分類して、異ベンチに応じた処理で実現できる
  - Unix系 は select や pollというシステムコールが使える (OSに依存しないが遅い)
  - Linuxなら epoll とうシステムコールが使える (高速だがOS依存)

IOイベントの監視とはつまり、ファイルディスクリプタの監視である。
例えばTCPコネクションが複数ある場合は、サーバーは複数のファイルディスクリプタを持つ。
それらのファイルディスクリプタに対して読み込みや書き込みが可能になったことを、selectなどの関数を用いると判定することができる。


epollの他にも POSIXにも AIO(asynchronous IO)というAPIが存在する。


# 5.2 コルーチンとスケジューリング
コルーチンとは、中断と再開ができる関数の総称



# 5.3 async/await 
Future は 将来のいつかの時点で値が決まる(あるいは一定の処理が終了する)データ型である。
プログラミング言語によってはPromiseやEventualと呼ばれる。

一般的にFutureはコル０亭によって実装され、これにより「中断、再開が可能な関数」から「将来に決定される値を表現したもの」へと意味的な変換が行われる。


Future型を用いた記述方法には明示的に記述する方法と暗黙的に記述する方法がある。
async/awaitは明示的なFuture型に対する記述と考えるよい。
- awaitはFuture型の値が決まるまで処理を停止して他の関数にCPUリソースを譲るために利用する
- asyncはFuture型を含む処理を記述するために利用する



# 5.4 
スレッドの生成はコストの高い操作のため、単位時間あたりのコネクション到着数が増加したとき、計算リソースが不足してしまう。
Tokioなどの非同期ライブラリの場合の場合、コネクション到着毎にスレッドを生成するのではなく、あらかじめスレッドを生成しておき、そのスレッドで各タスクを実行する (=スレッドプール)。
Tokioではデフォルトでは実行環境のCPUコア数と同じ数のスレッドを生成する。


async中にブロックするような処理を書いてはいけない。ワーカースレッドを専有してしまう。
たとえばtokioでsleepしたいなら tokio::time::sleepをつかうと、sleep中そのタスクを退避してくれる。
