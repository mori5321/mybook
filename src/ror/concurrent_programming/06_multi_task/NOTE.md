# マルチタスク

レジスタやスタック情報などのプロセスの状態に関する情報をコンテキストと呼び、
コンテキストの保存と復元の一連の処理をコンテキストスイッチと呼ぶ。

マルチタスク実行環境の定義
ある実行環境がマルチタスクである<=>任意のタイミングで新たなプロセスを生成可能、かつ計算途中にあるプロセスが公平に実行される

弱い公平性
ある実行環境が弱い公平性を満たす<=>あるプロセスが、ある時刻以降で実行可能だが待機状態になるとき、最終的にそのプロセスは実行される

強い公平性
ある実行環境が強い公平性を満たす<=>あるプロセスが、ある時刻以降で、実行可能な待機状態と実行不可な待機状態の遷移を無限に繰り返すとき、最終的にそのプロセスは実行される

線形時相論理で定式化される(DobrikovLP16)

## 協調と非協調的マルチタスク
コンテキストスイッチを行う戦略として、協調的と非協調的に行う2つの方法がある。

協調的コンテキストスイッチ => プロセス自らが自発的にコンテキストスイッチを行う
非協調的コンテキストスイッチ => 割り込みなどの外部的な強制力によってコンテキストスイッチを行う

協調的マルチタスク = cooperative multitasking (non-preemptive multitasking)
非協調的マルチタスク = preemptive multitasking


preemption
プロセスとの協調なしで行うコンテキストスイッチ

プロセスをどのようにコンテキストスイッチするかを決定するためのモジュール、関数、プロセスのことをスケジューラと呼ぶ


### 協調的マルチタスクの利点と欠点
利点: 実装が用意

初期のマルチタスクOSの多くはこれ
RustやPythonのasync/awaitは協調的マルチタスク

欠点: 自発的にコンテキストスイッチに行う必要があるため、あるプロセスにバグがあって無限ループや停止状態に陥った場合
そのプロセスが計算リソースを専有してしまう。開発者はそれを意識しなければならない。

Windows 3.1やMac OS 9は協調的マルチタスクで、アプリケーションがクラッシュするとOS全体がクラッシュしPCを再起動する必要があった。

RustやPythonのasync/awaitも同じ問題をかかえており、これらの機構を用いて無限ループやブロッキングを実装してしまうと、
コンテキストスイッチが行われずに実行速度が遅くなったり、最悪デッドロック担ってしまう。

### 非協調的マルチタスクの利点と欠点
無限ループやブロッキングのおような問題は起きない

現代的なOSはこれを採用している。
ErlangやGoは非協調的マルチタスク

欠点: 処理系の実装が難しい。

## 協調的グリーンスレッドの実装


## コンテキスト
コンテキストとは、プロセスの実行状態に関する情報であり、最も重要な情報はレジスタの値である。

- set_context
- switch_context

これはC言語のsetjpm, longjmpと同等の処理である。
