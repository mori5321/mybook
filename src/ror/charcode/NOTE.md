# Chapter1 文字とコンピューター
## 文字を符号化するということ

符号化 = CSにおいてはある情報をビットで表現すること

## 文字集合と符号化文字集合
### 文字集合(character set)
文字を何らかの意図を持って重複なく集めたものを文字集合という

### 符号化文字集合(coded character set)
文字集合を定義し、その集合の各文字に対するビット組み合わせを一意に定めたものを符号化文字集合という

## 符号化文字集合を実装するとはどういうことか? 
入出力される文字が、符号化文字集合によって決められるビット組み合わせに対応していること

- Keyboard [A] -> IN -> 0x41 (ASCIIにおけるA) 
- 0x41 -> OUT -> Monitor [A]

## 外部コードと内部コード
一般にシステム内部で利用される内部コードと、入出力に使われる外部コードは同じである必要がない。

ASCII Outer World(A=41) => Keyboard -> IN -> Convert -> 2341 -> UTF8 System (A=2341)
UTF8 System(A=2341) => Convert -> 41 -> OUT -> Monitor -> ASCII Outer World(A=41) 

現在のOSは内部コードとしてUTF-8を採用していることが多い

## 制御文字(control character)
改行などの文字の出力を制御するなどの役割を与えられたコード

### 主な制御文字
- ベル(Beep音を鳴らす)
- タブ
- 改行
- エスケープ

## 文字コードはなぜ複雑になるのか
### 過去の経緯の積み重ね
### 文字そのものの難しさ


# Chapter2 文字コードの変遷
- 最もシンプルな文字コード -> ASCII, ISO/IEC646
- 文字コードの構造と拡張方法を定めた -> ISO/IEC 2022
- 2バイト符号化文字集合の実用化 -> JIS X 0208
- 1バイト符号化文字集合の広がり -> ISO/IEC8859, Latin-1
- 国際符号化文字集合の模索と成立 -> Unicode, ISO/IEC 10646

## ASCII(American Standard Code for Information Interchange)
- 7bitの1bytecode で文字を表す。すなわち128の符号位置(code position)がある。
- 0x00 から 0x1F までは制御文字
- ASCIIは基本アメリカ向け
- ISO/IEC 646 => ASCIIをベースに各国用に空いてるところを拡張していいよってやつ
    - 日本は"JIS X 0201"
    - 0x5c: \ (バックスラッシュ) が 円記号になってる
    - 0x7e: ~ が ￣になってる

## ISO/IEC 2022(文字コードの構造と拡張方法を定めた)
ISO/IEC646では複数の言語を同時に扱えなくて困った

- ISO/IEC 2022
- ASCIIの拡張
- 8ビットが使える(255 code position)
- マルチバイト文字集合
    - 2バイト 3バイト で 1文字を表現する(だいたい2バイトが使われる)
- 符号化文字集合を呼び出す(切り替える)ことができる
    - 第８ビットの値で切り替える(第一文字集合、第二文字集合)
    - Escシーケンスで切り替える
    - 実際には ASCII + 自国用の文字集合という形で使われることが多かった

## JIS X 0208 (2バイト符号化文字集合の実用化), 符号化方式の成立
漢字圏における情報処理に多大な貢献をした。
しかし2バイト文字集合単独では課題があり、1バイト文字集合との組み合わせによる運用が普及していく。

- JIS X 0208
    - 漢字を扱う
    - JISなので当然 from 日本
    - ISO/IEC 2022 に準拠した2バイト文字集合は 94 x 94 = 8836 の code position
        - 常用漢字(2,136)ぐらいなら入る
    - 漢字だけでなく、ラテン文字やギリシャ文字、算用数字なんかも入ってる 。多言語化を指向。
- 符号化方式の成立
    - 「漢字圏なので2バイトがほしい、でも1バイトコードの資産も使いたい...」
    - JIS X0208 を ASCII や JIS X 2021 といった 1バイトコードと組み合わせて運用する方式が開発され広く普及した
    - Shift_JIS とか EUC-JP、ISO-2022-JP とかがそれ。符号化方式。
    - ISO/IEC 2022 に準拠したものもあれば、準拠していないものもある
        - EUC-JPやISO-2022-JP は準拠している
        - Shift_JIS は準拠していない()

## ISO/IEC 8859, Latin-1(1バイト符号化文字集合の広がり)
そのころ一方ヨーロッパでは、比較的必要とする文字数が少ないため 8bit 1バイトコードが普及。
しかし1バイトではヨーロッパ全域の文字をカバーできなかったため、地域ごとの1バイトコードが生まれた(乱立した)。

詳細は割愛


## Unicode, ISO/IEC 10646 (国際符号化文字集合の模索と成立)
符号化文字集合の組み合わせや切り替えによって多言語化を図るアプローチに代えて、
1つの大きな符号化文字集合で世界中の文字をカバーするという構想が計画され、実行に移された。
紆余曲折あった。

Unicode
- 最初は16bit(すなわち2byte)でいこうとした。
- 65,536文字ではどう考えても足りなかった
- Unicodeの中で文字が割り当てられていない未使用の領域の16ビットの符号単位を2つ並べることで、拡張部分の1文字を表現する符号化方式が開発された
    - これがUTF-16
    - サロゲートペアのこと？
- ASCIIとバイト単位で互換となるように計算式によって変形を施したのが UTF-8
    

# Chapter3 代表的な符号化文字集合
## ASCII と ISO/IEC 646 (最も基本的な1バイト集合)

## JIS X 0201 (ラテン文字とカタカナの1バイト集合)
Shift_JIS のベースとしていまも使われている

ラテン文字集合とカタカナ集合の2つの符号化文字集合を定めている。いずれも1バイト集合。
ラテン文字集合はASCIIとほぼ同じ。バックスラッシュが円記号に、チルダ~がオーバーライン￣になっている。
カタカナ集合は、濁点半濁点の付いた文字を含まない。濁点半濁点は別の文字として定義されている。
JIS X 0201 は 俗に半角カタカナと呼ばれるが、半角幅で表示することを求めるものではない。

## JIS X 0208 (日本の最も基本的な2バイト文字集合)
1978年制定
ISO/IEC 2022に準拠

2バイト文字集合
たとえば愛という字には 0110000(7bit) 0100110(7bit) というコードが割り当てられている。
これをGL領域によびだせば 00110100 00110110 (3026) というコードになる。
これをGR領域によびだせば 10110000 10100110 (B0A6) というコードになる。

符号化方式 JIS X 0208 には2種類の符号化方式がある。
Shift JIS と ISO-2022-JP を公的標準として取り込んだもの。

空き領域には機種依存文字が割り当てられている

## JIS X 0212 (補助漢字)
あんまつかわれてない

skip

## JIS X 0213(漢字第三・第四水準への拡張)
- 文字足した
- ASCIIとの互換性を強化した(JIS 0208との比較で)
  - ", ', -, ~ あたりがASCIIと似て非なる字しかもっていなかった。

### 符号化方式
合計9個、主要なのは3つ
Shift_JIS-2004 ISO-2022-JP-2004 ECU-JIS-014

## ISO/IEC 8859(欧米で広くつかわれる1バイト符号化文字集合)
skip


## Unicode と ISO/IEC 10646 (国際符号化文字集合)
Unicode -> ISO/iEC 10646 -> JIS X 0221
        <- 　　　　　　　技術的内容が一致するように作成
       同一の文字表
       になるように同期

### 符号の構造
4バイト(UCS-4) または 2バイトの符号(USC-2)で表す

USC-4は群(group), 面(plane), 区(row), 点(cell)に対応する
群は00~7F(128)
面・区・点はそれぞれ00~FF(256)
USC-4には全部で2^31の符号位置があることになる。ほぼ無限。

群00の面00がUCS-2に相当する面であり、この面を基本多言語面(BMP)という。
BMPはもともとんおUnicodeにあたる。以後、面xxというときは16進数で表記する。
すなわち面10とは面00から数えて17番目の面である。

UCS-2(もともとのUnicode)ではBMPの文字しか表現できない。そこでUCS-2を拡張したUTF-16が生まれた。
UTF-16ができてBMP以外の面も指すことができるようになったとはいえ、この方式で表現できるのは
最初の17の面の符号位置だｋである。そこで現在では、UTF-16で表すことのできない面は削除された(群00の面10より先の面)。

通常用いる文字の多くはBMPに含まれている。
漢字が面02に。面01には歴史上の文字が含まれている。面0Eには特殊用途符号が。
面0Fと面10は私用領域、利用者が好きに使える。

### Unicodeの符号位置の表し方
U+4E00 のように表す
接頭辞U+ をつけた 4 ~ 6桁の16進数
BMP内の符号位置は4桁で表すので、4桁の形式を見ることが多い
例: U+4E00 => BMPの「一」

UTF-16で指し示すことのできる符号位置の上限はU+10FFFF

### 基本多言語面(BMP)
使用機会の多い文字はだいたいここに入ってる。多くの言語の文字が含まれている。

### 結合文字
Unicodeの特徴の一つとして、複数の部品の合成によって1文字を表すことがある。
合成のために用いる文字を結合文字という。

たとえば nと~を合成してñを表す。nと~はそれぞれU+006EとU+0303である。
nを規定文字、~を結合文字という。結合文字は合成のためのみに用いて、単独では用いない。

ちなみに ñ には単独の符号位置も与えられており、 U+00F1 である。
つまり合成によって符号化されることもあるし、単独で符号化されることもある。

ñ(U+00F1) = n(U+006E) + ~(U+0303)

1つの文字が複数の符号化表現を持つことは問題を引き起こす。
それをいずれかの表現方式に揃える方法が「正規化」という。(後述する)

### 既存の符号化文字集合との関係
Unicodeは各文字に名前を当てている。
たとえば 大文字のA(U+0041) は LATIN CAPITAL LETTER A という名前がついている。
この文字名は他の符号化文字集合との間で文字の対応をとる際に役に立つ

#### ISO/IEC 8859-1 と Unicodeの関係
Unicodeは先頭の128符号位置はASCIIと同等、その先の128符号位置はISO/IEC 8859-1(欧州で普及した1バイト符号化文字集合)と同等になっている。
Latin-1からUnicode(UTF-16)に変換するには、各バイトの先頭に00を入れるだけでよい。

#### 全角・半角系
Shift_JIS や EUC-JPのような1バイトコードと2バイトコードを併用する東アジアの符号化方式では、
同じ文字が2つのコード値を持つことがある。これを重複符号化という。

こうしたコードからUnicodeへ変換を行うとき、1バイトと2バイトの「A」を同じ U+0041に対応づけると、逆方向に戻すことができない。

Shift JIS A(41 1バイトのA)   => Unicode(U+0041)
Shift JIS A(8260 2バイトのA) => Unicode(U+FF41)

これによって往復変換ができるようになる。
全角・半角系と呼ぶ。

#### 漢字統合(CJK統合漢字)
CJK = China, Japan, Korea
漢字統合 = 形の違いがわずかなものは1つの符号位置に統一するというもの。
  例: 海とか 日本だと中棒だが、中国や韓国では中点。些末な違いなので同じ符号位置にしてしまう。

#### 互換漢字
互換漢字とは、他の文字コードとの互換性のために使うことを想定して設けられたUnicodeの漢字のこと。
たとえば韓国の漢字コード規格では、読みを複数持つ漢字は複数重複して出現する。一方、Unicodeでは重複を許さない。
このままでは韓国の文字コードとUnicodeの往復変換ができない。つまり、全角・半角系同様の理由で互換漢字が設けられた。

たとえばJIS X 0213 では 海(中棒)と海(中点)は分離された。
しかしUnicodeではそれらはすでに統合されているので、 JIS X 0213 の新たな海(中点; 1-86-73) を統合漢字に追加することはしない。
かといってそのままにしておくと、往復変換ができないので、海(中点; 1-86-73) を互換漢字として新たに追加することで対応を図っています。

#### 互換漢字と正規化問題
互換漢字はUnicodeの正規化という操作によって、対応する統合漢字に置き換えられてしまうという性質がある。
たとえば、互換漢字の海(中点)は正規化によって統合漢字の海(中棒)に変換される。
詳細は後述する。

#### JIS X 0213 と Unicodeの関係
JIS X 0213:2000 は 当時のUnicodeになかった文字を収録した。
2002年のUnicode 3.2 でこれらの文字が収録され追い付いた。
しかし、プログラムで処理する上ではいくつかの注意点がある。

1. BMP以外の面の漢字の存在
2. 結合文字の使用の必要
3. 互換漢字の正規化問題

##### 1. BMP以外の面の漢字の存在
JIS X 0213 の漢字のうち、303文字がBMPでなく面2に配置されている。
これに対応するために 
- UTF-16 ではサロゲートペアを扱えること
- UTF-8 では4バイトの範囲を扱えること
が必要。

Unicode対応のソフトウェアであっても、BMP以外の面の文字をうまく扱えない古いシステムがたまにある。
たとえばWindows XPのメモ帳は面02にある漢字を表示できるが、Backspaceで削除するとあたかも文字が2つあるかのような挙動を見せる。
たとえばMySQLではutf8と指定すると3バイトまでしか対応しない、4バイト文字を扱いたければutf8mb4と指定する必要がある。

BMP外の字だから対応の必要性が低いかというと、そうでもない。
普通に現代に使われている感じがある (住所や名字に使われているレア漢字)

##### 2. 結合文字の仕様の必要
Unicodeでは25種類の文字に単一の符号文字が与えられておらず、結合文字を使って2つの符号位置の組み合わせで表現する。

1文字が1つの符号位置だと家庭しているプログラムでは、問題が生じる可能性がある。
実際Unicodeに対応しているソフトウェアであっても、結合文字については対応の程度がさまざまである。

##### 3. 互換漢字の正規化の問題
先述したため省略

#### 絵文字
ダルいので割愛


## Column: Unicode と UTF-8/UTF-16 の関係
Unicode は 整数値で表せる符号位置と文字とを対応づけている。

たとえば「山 => U+5C71」はUnicodeで決まっている。
その整数である符号位置をどうバイトで表現するかが符号化方式である。
UTF-16 ならば 山 => U+5C71 => 5C 71 (2バイト)
UTF-8 ならば 山 => U+5C71 => E5 B1 B1 (3バイト)



# Chapter4. 代表的な文字符号化方式
## JIS X 0201 の符号化方式
### 8ビット符号
8ビット符号表の GL領域にラテン文字集合を、GR領域にカタカナ集合を呼び出して用いる符号化方式
8ビットの1バイトですべての文字を表す。

GL => 第8ビットが0
GR => 第8ビットが1

すなわちコードが0x7F以下のバイトはラテン文字集合、0xA0以上のバイトはカタカナ集合の文字を表すのに使われる。

この符号化方式はShift_JISのベースになっている。


### 7ビット符号
- 1. ラテン文字用7ビット符号
- 2. カタカナ用7ビット符号
- 3. ラテン文字・カタカナ用7ビット符号

1,2 => 片方だけでいいときつかう。
3 => どちらもGL領域に呼び出し、制御文字によって切り替える(用いる制御文字はSHIFT)

近年あんまり使われてない

## JIS X 0208 の符号化方式
- 漢字用7ビット符号
- EUC-JP
- ISO-2022-JP
- Shift_JIS

### 漢字用7ビット符号
skipped

### EUC-JP
Unix系の環境でよくつかわれる

### ISO-2022-JP
GRは使用せずに、GLだけでASCIIやJISを表現する。
エスケープシーケンスによってGL内の文字集合を切り替える。

エスケープシーケンスによって切り替えるということは、
状態を持つ符号化方式である。

エスケープシーケンス
1B 28 42 => ASCII 1B 28 42 => ESC ( B 
1B 28 4A => JIS X 0201 ラテン文字 => ESC ( J
1B 24 40 => JIS X 0208 1978 => ESC $ @
1B 24 42 => JIS X 0208 1983 => ESC $ B 

### Shift_JIS
JIS X 0201 の 8ビット符号の隙間に、JIS X 0208 を変形した上押し込んだもの。
元のJISにはなかったが、1980年代各社のPCに実装されるようになり、事実上の標準となった。


## Unicodeの符号化方式
### UTF 概説
UTF-16 が Unicode の直系といえる形式。
ただし16ビットでは足りなくなったので、16ビット符号単位2つの組み合わせを使うことでBPM外の面の符号位置を表現する。

UTF-32 は 32ビットなので、32ビット固定幅ですべての符号位置を表現できる。

ASCIIとの互換性が必要な場合にはUTF-8が使われる。
この符号化方式は1バイト(8bit)から4バイト(32bit)の可変長で表され、1バイトの部分はASCIIと互換性がある。

### UTF-16
Javaの文字列表現で使われている。

#### サロゲートペア
BPM以外の面の文字を表すために、サロゲートペア(surrogate pair)という仕組みを用いる。
* surrogate = 代理

BMPの中の文字の割り当てのない符号位置2つを用いて、BMP外の面の符号位置を指すもの。
サロゲートペアに用いる領域は
- U+D800 ~ U+DBFF (上位サロゲート)
- U+DC00 ~ U+DFFF (下位サロゲート)

上位サロゲートと下位サロゲートの組み合わせで、BMP外の面の符号位置を表す。

#### バイト順の問題 - ビッグエンディアンとリトルエンディアン
16ビットのデータを8ビット単位のバイト列にするときに、上位8ビットから先に並べるか 下位8ビットから先に並べるか という問題。
byte order という。

上位8ビットが先頭にくる => big endian
下位8ビットが先頭にくる => little endian

Unicode特有の用語ではなく、ビット列をバイト単位で表現するときにしばしば使われる。

UTF-16 はビッグエンディアンとリトルエンディアンの両方がある。
UTF-16BE => ビッグエンディアン
UTF-16LE => リトルエンディアン

#### BOM(Byte Order Mark)
どちらのバイト順を採用しているかを示すために、データの先頭にByte Order Markと呼ばれる印をつけることがある。
BOMには U+FEFF の符号位置を用いる。この符号位置はビッグエンディアンではFE FF, リトリエンディアンでは FF FE という2バイト列となる。
もしデータの先頭に FF FE といういバイト値が来ていれば、BOMがリトルエンディアンで表されているということがわかる。
同様にデータの先頭がFF FEならばビッグエンディアンで表されている。
U+FFFE の符号位置は文字としては使われないことになっているので、文字の表現としてFE FFやFF FEが現れることはない。

#### 適した用途
内部処理で用いられることの多い形式。

### UTF-32
各符号位置が4バイト固定幅。サロゲートペアが不要。
UTF-16同様に、BOMでバイト順を示すことができる。

#### 適した用途
00になるバイトが多いため、記憶容量の無駄が多い。

### UTF-8
8ビット単位、可変長(1~4バイト)
ASCIIとの互換性がある

符号位置によってバイト数があらかじめ決まっている
逆にバイトから符号位置を求めるときには、先頭バイトのビットパターンからバイト数を判断することができる (?; by GPT)

#### ASCIIとの互換性
skip

#### 冗長性の問題
1つの符号位置を符号化するのに複数の方法がある。

たとえば、ディレクトリトラバーサルなど(..)を可能にする文字列のチェックをすり抜けることが可能なようなシステムをつくることができてしまう。

#### BOM付きUTF-8の問題
バイト順が問題になることのないUTF-8は本来BOMが不要。
しかし、UTF-8であることをしめすために EE BB BF が先頭についていることがある。
このようなBOM付きUTF-8は、ASCIIと非互換になってしまう。

#### 適した用途
ASCIIとの互換性が必要なデータフォーマットやプロトコルなどに適している
3バイト使うのでサイズ効率は良くない


# Chapter5 文字コードの変換と判別
## 変換ツール
iconv, nkf

## 変換できないとき
変換元のテキストに含まれる文字が変換先文字コードにない場合は変換できない。
UTF-8 -> Shift_JIS などでそういうことが起こる。

## 変換の原則
文字集合が同一で、符号化表現だけが異なるようなコード間の変換は簡単。符号位置をチェックすれば正しい変換ができたかどうかをチェックできる。jjjjjjj
しかし文字集合体系が異なる文字コード間で変換することは困難が伴う。(詳細は割愛)

## 判別のツール
nkf


# Chapter6 インターネットと文字コード

# Chapter7 プログラミング言語と文字コード
skip

# Chapter8 はまりやすい落とし穴とその対処
## トラブル調査の必須工具 - 16進ダンプツール
od 

## 文字化け
## 改行コード
## 全角・半角 問題
## 円記号問題
## 波ダッシュ問題


